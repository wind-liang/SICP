;将书上的费马检查代码写入，改变判断素数的方法即可。
;http://sicp.readthedocs.io/en/latest/chp1/24.html
可以看到，新的 search-for-primes 比起 练习 1.22 的 search-for-primes 在速度上有所改进，
但是当 search-for-primes 的输入增大一倍的时候，
计算所需的时间并不是按预期的那样，
严格地按常数增长，
比如计算 (search-for-primes 1000000) （一百万）
的速度就比计算 (search-for-primes 1000) （一千）的速度要慢 4 倍。

通过对 练习 1.22 、 练习 1.23 和 练习 1.24 (本题)的三个版本的 search-for-primes 进行测试，
我们发现，使用算法复杂度或者计算步数并不能完全预测程序的运行时间 —— 的确如此。

首先，即使我们能准确地计算出程序所需的步数，程序的运行速度还是会受到其他条件的影响，
比如计算机的快慢，系统资源的占用情况，或者编译器/解释器的优化程度，等等，
即使是同样的一个程序，在不同情况下运行速度也会有所不同，
所以程序的计算步数能对程序的运行状况给出有用的参考信息，
但是它没办法、也不可能完全准确预测程序的运行时间。

另一方面，算法复杂度比计算步数更进一步，它无须精确计算程序的步数 —— 算法复杂度考虑的是增长速度的快慢：
比如说，当我们说一个算法 A 的复杂度比另一个算法 B 的复杂度要高的时候，
意思是说，算法 A 计算所需的资源（时间或空间）要比算法 B 要多。

一般来说，复杂度更低的算法，实际的运行速度总比一个复杂度更高的算法要来得更快，
有时候在输入比较小时会比较难看出差别，但是当输入变得越来越大的时候，低复杂度算法的优势就会体现出来。

